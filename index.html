<!DOCTYPE html>
<html>
	<head>
		<title>shaderpopcorn</title>
		<meta charset="utf-8">
  		<meta name="description" content="color">
  		<meta name="author" content="KW">
  		<meta name="viewport" content="width=device-width, initial-scale=1.0">
  		<link rel="stylesheet" href="css/style.css">
	</head>
	<body>
    <div id="container"></div>
    <script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">


				uniform float time;
				uniform vec2 resolution;
				uniform vec2 mouse;
				uniform vec3 spectrum;

				uniform sampler2D texture0;
				uniform sampler2D texture1;
				uniform sampler2D texture2;
				uniform sampler2D texture3;
				uniform sampler2D prevFrame;
				uniform sampler2D prevPass;
				float PI = 3.1415;

				float DistLine(vec2 p, vec2 a, vec2 b){         // draws a line segment not an infinite line
				vec2 pa = p-a;
				vec2 ba = b-a;
				float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);
				return length(pa-ba*t);
				}

				float N21(vec2 p){
				p = fract(p*vec2(233.34, 851.73));
				p += dot(p,p+23.45);
				return fract(p.x*p.y);
				}

				vec2 N22(vec2 p){
				float n = N21(p);
				return vec2(n, N21(p+n));
				}

				vec2 GetPos(vec2 id, vec2 offs){                    // animation of point
				vec2 n = N22(id+offs)*time;
				return offs+sin(n)*.4;                          // at .5 the dots would hit the border of the gv
				}

				float Line(vec2 p, vec2 a, vec2 b){
				float d = DistLine(p,a,b);
				float m = smoothstep(.02,.005,d);
				float d2 = length(a-b);
				m *= S(1.2,.8,d2)*.5+S(.05,.03,abs(d2-.75));    // it fades the lines depending on the length of the line segment
																												// makes the lines flash when they are above a certain threshold
				return m;
				}

				float Layer(vec2 uv){
				float m = 0.;
				vec2 gv = fract(uv)-.5;
				vec2 id = floor(uv);


				vec2 p[9];                              // setup an array of 9 positions
				int i = 0;                              // setup an index to count through the loops
				for(int y=-1; y<=1; y++){
						for(int x=-1; x<=1; x++){
								p[i] = GetPos(id,vec2(x,y));    // get the position of each point in each gv and add the offset
								i++;
						}
				}

				float t = time*5.;

				for(int i=0; i<=8; i++){
						m += Line(gv, p[4], p[i]);          // each time we get through the loop we draw a line from the middle gv to the gv the loop is currently at

						vec2 j = (p[i]-gv)*20.;             // vector from point that we are looking at to the current pixel that we are at / *20 makes the vector longer
						float sparcle = 1./dot(j,j);
						float twinkle = sin(t+fract(p[i].x)*10.)*.5+.5;
						m += sparcle * twinkle;
				}

				m += Line(gv, p[1], p[3]);              // draw line from gv 1 to gv 3
				m += Line(gv, p[1], p[5]);              // draw line from gv 1 to gv 5
				m += Line(gv, p[7], p[3]);              // draw line from gv 7 to gv 3
				m += Line(gv, p[7], p[5]);              // draw line from gv 7 to gv 5
				return m;
				}

				void main(void)
				{
				vec2 uv = (gl_FragCoord.xy-.5*resolution.xy)/resolution.y;
				vec3 col = vec3(0);

				float gradient = uv.y;                  // define uv.y so I can use it after the rotation as an unrotated variable
				float m = 0.;
				float t = time*.1;

				float s = sin(t);
				float c = cos(t);
				mat2 rot = mat2(c,-s,s,c);
				uv *= rot;

				for(float i=0.; i<1.; i+=1./4.){
						float z = fract(i+t);               // multiple layers that move forward (once they get to one the snap back to 0)
						float size = mix(10.,.5,z);         // 10. --> larger repititions means smaller look
						float fade = smoothstep(0.,.5,z)*smoothstep(1.,.7,z); // first smoothstep teh layers fade in over the first 50% / second smoothstep is for the fade out (faster)
						m += Layer(uv*size+i*20.)*fade;   // i*20. --> shifts the layers, so we look at a different part of each layer

				}

				vec3 base = sin(t*5.*vec3(.345, .456,.657))*.4+.6;
				col = m*base;

				col -= gradient*base+spectrum;
				//    col.rg = gv;

				//    if(gv.x>.48 || gv.y>.48) col.r=1.;

				gl_FragColor = vec4(col,1.);
				}
    </script>
    <script>
        var container;
        var camera, scene, renderer;
        var uniforms;

        init();
        animate();

        function init() {
            container = document.getElementById( 'container' );

            camera = new THREE.Camera();
            camera.position.z = 1;

            scene = new THREE.Scene();

            var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

            uniforms = {
                time: { type: "f", value: 1.0 },
                resolution: { type: "v2", value: new THREE.Vector2() },
                mouse: { type: "v2", value: new THREE.Vector2() }
            };

            var material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent
            } );

            var mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );

            container.appendChild( renderer.domElement );

            onWindowResize();
            window.addEventListener( 'resize', onWindowResize, false );

            document.onmousemove = function(e){
              uniforms.mouse.value.x = e.pageX
              uniforms.mouse.value.y = e.pageY
            }
        }

        function onWindowResize( event ) {
            renderer.setSize( window.innerWidth, window.innerHeight );
            uniforms.resolution.value.x = renderer.domElement.width;
            uniforms.resolution.value.y = renderer.domElement.height;
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            uniforms.time.value += 0.05;
            renderer.render( scene, camera );
        }
    </script>
	</body>
</html>
